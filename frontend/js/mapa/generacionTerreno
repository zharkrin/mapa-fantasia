// ğŸ“‚ frontend/js/mapa/generacionTerreno.js

// ImplementaciÃ³n simple de Perlin Noise en 2D
class Perlin {
  constructor() {
    this.permutation = [];
    this.p = [];

    for (let i = 0; i < 256; i++) {
      this.permutation[i] = Math.floor(Math.random() * 256);
    }

    this.p = this.permutation.concat(this.permutation);
  }

  fade(t) {
    return t * t * t * (t * (t * 6 - 15) + 10);
  }

  lerp(t, a, b) {
    return a + t * (b - a);
  }

  grad(hash, x, y) {
    const h = hash & 3;
    const u = h < 2 ? x : y;
    const v = h < 2 ? y : x;
    return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
  }

  noise(x, y) {
    const X = Math.floor(x) & 255;
    const Y = Math.floor(y) & 255;

    const xf = x - Math.floor(x);
    const yf = y - Math.floor(y);

    const topRight = this.p[this.p[X + 1] + Y + 1];
    const topLeft = this.p[this.p[X] + Y + 1];
    const bottomRight = this.p[this.p[X + 1] + Y];
    const bottomLeft = this.p[this.p[X] + Y];

    const u = this.fade(xf);
    const v = this.fade(yf);

    const x1 = this.lerp(
      u,
      this.grad(this.p[bottomLeft], xf, yf),
      this.grad(this.p[bottomRight], xf - 1, yf)
    );
    const x2 = this.lerp(
      u,
      this.grad(this.p[topLeft], xf, yf - 1),
      this.grad(this.p[topRight], xf - 1, yf - 1)
    );

    return (this.lerp(v, x1, x2) + 1) / 2; // Normalizado 0â€“1
  }
}

const perlin = new Perlin();

/**
 * Genera un mapa de terreno usando ruido Perlin
 * @param {number} ancho - nÃºmero de celdas en X
 * @param {number} alto - nÃºmero de celdas en Y
 * @param {number} escala - nivel de detalle del ruido
 */
export function generarTerreno(ancho, alto, escala = 20) {
  const mapa = [];

  for (let y = 0; y < alto; y++) {
    const fila = [];
    for (let x = 0; x < ancho; x++) {
      const nx = x / escala;
      const ny = y / escala;
      const valor = perlin.noise(nx, ny);
      fila.push(valor);
    }
    mapa.push(fila);
  }

  return mapa;
}